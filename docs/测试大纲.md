# 测试大纲

## 测试目的

通过单元测试和集成测试，尽最大可能保证局部模板的正确性，进而使整个设计正确，满足设计功能需求和处理器的使用需求。

## 测试模块

首先，`NPC`的微架构设计中，将其分为控制层，冒险层和数据通路层三个层面，即需要对这三个层面进行测试。其次，模块电路(`utils`文件夹中)是构成这三层的最小单元，应当对其进行仔细的单元测试。

### 模块

| 名称       | 测试内容                                                     | 测试方法   |
| ---------- | ------------------------------------------------------------ | ---------- |
| `ImmGen`   | 检查是否能够输出与指令类型对应的立即数；是否进行了正确的符号扩展 | 边界值分析 |
| `Register` | 检查寄存器是否可以正常读写                                   | 动作桩覆盖 |
|            |                                                              |            |

### 控制

控制模块仅有`ControlUnit`模块，其作用为根据输入的指令产生对应指令需要的控制信号。测试需要检查其生成的控制信号是否与对应的指令对应。理想的测试方法，穷尽测试。

### 冒险

冒险模块也仅有`HazardUnit`模块，其作用未根据输入的各个流水阶段的状态信息，来决定是否需要暂停或者冒泡某个流水阶段以防止数据冒险和控制冒险，并且，决定是否要接受转发的数据等。由于输入条件量较小，且不太需要将所有输入范围进行测试，所以随机选取几个特例，对输入条件进行组合测试。

### 数据通路

| 名称             | 测试内容                                                     | 测试方法               |
| ---------------- | ------------------------------------------------------------ | ---------------------- |
| `InstFetchUnit`  | 检查其是否能根据使能信号对寄存器的值更新（由于该单元具有DPI-C部分，故无法对这一部分进行测试） | 集成测试，条件覆盖测试 |
| `InstDecodeUnit` | 检查单元的输出是否符合当前指令预期期望的译码结果，同时检查使能和重置信号。同时，随机检查个别指令的译码结果是否正确 | 集成测试，AD测试       |
|                  |                                                              |                        |

## 测试用例

### 模块

#### `ImmGen`

该模块的作用是生成与指令类型对应的立即数。需要测试其正确生成立即数以及是否进行了符号扩展。

| 测试编号 | 测试内容                   | 输入条件                                | 期望结果                    | 实际结果 |
| -------- | -------------------------- | --------------------------------------- | --------------------------- | -------- |
| 1        | 符号扩展<br />I-type立即数 | in：0x1ff8202<br />imm_type：IMM_TYPE_I | imm_out：0xfffffffffffffffc | 通过     |
| 2        | S-type立即数               | in：0x82268<br />imm_type：IMM_TYPE_S   | imm_out：0x48               | 通过     |
| 3        | 符号扩展<br />B-type立即数 | in：0x1fd1321<br />imm_type：IMM_TYPE_B | imm_out：0xffffffffffffffe0 | 通过     |
| 4        | U-type立即数               | in：0x122<br />imm_type：IMM_TYPE_U     | imm_out：0x9000             | 通过     |
| 5        | J-type立即数               | in：0x1eebfe1<br />imm_type：IMM_TYPE_J | imm_out：0xffffffffffffff74 | 通过     |

#### `Register`

寄存器堆。

| 测试编号 | 测试内容         | 输入条件                                                     | 期望结果                                              | 实际结果 |
| -------- | ---------------- | ------------------------------------------------------------ | ----------------------------------------------------- | -------- |
| 1        | 读端口1          | 初始化，向1号寄存器写入值"h1234".U。然后尝试从读端口1尝试读取该寄存器的值。 | 从读端口1输出的值为"h1234".U，从读端口2读出的值为0。  | 通过     |
| 2        | 读端口2          | 初始化，向3号寄存器写入值"h13456".U。然后尝试从读端口2尝试读取该寄存器的值。 | 从读端口2输出的值为"h13456".U，从读端口1输出的值为0。 | 通过     |
| 3        | 写端口           | 向17号寄存器写入值"h17".U，同时也在该时钟周期在读端口1尝试读取该寄存器的值。 | 读取的值为"h17".U。                                   | 通过     |
| 4        | 写入后两周期再读 | 初始化，向10号寄存器写入"hffff".U，然后从读端口1读取该寄存器的值。在下一个时钟周期的时候，向10号寄存器写入值"h7890".U，但是使能信号为0，同时在读端口1读取10号寄存器的值。 | 两次读取的结果均为"hffff".U。                         | 通过     |
| 5        | 0寄存器写读      | 向0号寄存器写入非0值"hcdcd".U，然后读取0号寄存器。           | 读取出的结果为0。                                     | 通过     |

### 控制

控制单元主要就根据输入的指令来生成指令需要的控制信号。需要测试其能否正确译码出指令需要的控制信号。

### 冒险

冒险单元将根据输入的各个流水阶段的状态信息来决定是否要暂停或者冒泡某个阶段，以及决定是否要接受转发的数据。需要测试其能否根据输入的状态信息来生成正确的暂停，冒险的控制信号，以及转发的控制信号。

在该测试中，输入条件有`rs1`，`rs2`，`rd_E`，`rd_M`，`rd_W`五个输入条件。有`enable_F`，`enable_D`，`reset_D`，`reset_E`，`fa_ctl`，`fb_ctl`输出条件。我们对输入条件可能存在的情况进行组合测试，输入条件可能的情况如下：

![image-20230801122024796](https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20230801122024796.png)

同时，我们还需要检查其**多个条件满足的优先级**的处理是否正确，然后对**源寄存器为0**的情况进行测试。

| 测试 编号 | 测试内容                                 | 输入条件                                                     | 期望结果                                                     | 实际结果 |
| --------- | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1         | 无冲突，不需要访存                       | rs1 = 0, rs2 = 1, rd_E = 2, rd_M = 3, rd_W  = 4, wb_ctl_E = WB_CTL_ALU, wb_ctl_M = WB_CTL_MEM, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_DEFAULT | 通过     |
| 2         | 有冲突，需要访存                         | rs1 = 11, rs2 = 12, rd_E = 11, rd_M = 13,  rd_W = 14, wb_ctl_E = WB_CTL_MEM wb_ctl_M = WB_CTL_MEM, jump_sig = false | enable_F = false, enable_D = false, reset_D = false, reset_E = true, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_DEFAULT | 通过     |
| 3         | 有冲突，不需要访存                       | rs1 = 21, rs2 = 22, rd_E = 22, rd_M = 23,  rd_W = 14, wb_ctl_E = WB_CTL_ALU,  wb_ctl_M = WB_CTL_MEM, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_ALU_E | 通过     |
| 4         | 有冲突，不需要访存                       | rs1 = 17, rs2 = 10, rd_E = 11, rd_M = 17,  rd_W = 14, wb_ctl_E = WB_CTL_ALU,  wb_ctl_M = WB_CTL_MEM, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_MEM_M, fb_ctl = F_CTL_DEFAULT | 通过     |
| 5         | 有冲突，不需要访存                       | rs1 = 7, rs2 = 2, rd_E = 11, rd_M = 17,  rd_W = 2,  wb_ctl_E = WB_CTL_ALU,  wb_ctl_M = WB_CTL_MEM, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_WB_DATA | 通过     |
| 6         | 有多个冲突                               | rs1 = 31, rs2 = 5, rd_E = 11, rd_M = 31,  rd_W = 31,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_SNPC_M, fb_ctl = F_CTL_DEFAULT | 通过     |
| 7         | 与两个源寄存器冲突，在不同阶段           | rs1 = 13, rs2 = 15, rd_E = 13, rd_M = 31,  rd_W = 15,  wb_ctl_E = WB_CTL_SNPC,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_SNPC_E, fb_ctl = F_CTL_WB_DATA | 通过     |
| 8         | 与两个源寄存器冲突，在不同阶段，需要访存 | rs1 = 13, rs2 = 15, rd_E = 13, rd_M = 31,  rd_W = 15,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false | enable_F = false, enable_D = false, reset_D = false, reset_E = true, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_WB_DATA | 通过     |
| 9         | 与两个源寄存器冲突，在相同阶段           | rs1 = 15, rs2 = 15, rd_E = 11, rd_M = 15,  rd_W = 9,  wb_ctl_E = WB_CTL_ALU,  wb_ctl_M = WB_CTL_ALU, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_ALU_M, fb_ctl = F_CTL_ALU_M | 通过     |
| 10        | 有冲突，但冲突寄存器为0                  | rs1 = 0, rs2 = 15, rd_E = 0, rd_M = 0,  rd_W = 0,  wb_ctl_E = WB_CTL_ALU,  wb_ctl_M = WB_CTL_ALU, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_DEFAULT | 通过     |

对于控制冒险的测试，当存在需要跳转的时候，暂停和冒泡的控制信号正确。

| 测试编号 | 测试内容           | 输入条件                                                     | 期望结果                                                     | 实际结果 |
| -------- | ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1        | 如果存在跳转的情况 | rs1 = 31, rs2 = 5, rd_E = 11, rd_M = 31,  rd_W = 31,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = true | enable_F = true, enable_D = true, reset_D = true, reset_E = true, fa_ctl  = F_CTL_SNPC_M, fb_ctl = F_CTL_DEFAULT | 通过     |

### 数据通路

#### `InstFetchUnit`

| 测试编号 | 测试内容 | 输入条件         | 期望结果                   | 实际结果 |
| -------- | -------- | ---------------- | -------------------------- | -------- |
| 1        | 使能     | 使能信号为高电平 | pc寄存器输出了更新后的结果 | 通过     |
| 2        | 使能     | 使能信号为低电平 | pc寄存器仍然保持之前结果   | 通过     |

#### `InstDecodeUnit`

| 测试编号 | 测试内容   | 输入条件                                                     | 期望结果                                                   | 实际结果 |
| -------- | ---------- | ------------------------------------------------------------ | ---------------------------------------------------------- | -------- |
| 1        | 重置，使能 | 使能信号为高电平，重置信号为高电平                           | pc寄存器的值被更新为0，或者是未发生变化（如果初始值为0且） | 通过     |
| 2        | 重置，使能 | 使能信号为高电平，重置信号为低电平                           | pc寄存器的值被更新为输入的值                               | 通过     |
| 3        | 使能       | 初始化将寄存器的值更新为其他值，然后使能信号为低电平，重置信号为低电平 | pc寄存器的值未更新                                         | 通过     |


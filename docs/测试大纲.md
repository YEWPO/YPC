# 测试大纲

## 测试目的

通过单元测试和集成测试，尽最大可能保证局部模板的正确性，进而使整个设计正确，满足设计功能需求和处理器的使用需求。

## 测试模块

首先，`NPC`的微架构设计中，将其分为控制层，冒险层和数据通路层三个层面，即需要对这三个层面进行测试。其次，模块电路(`utils`文件夹中)是构成这三层的最小单元，应当对其进行仔细的单元测试。

### 模块

| 名称         | 测试内容                                                     | 测试方法               |
| ------------ | ------------------------------------------------------------ | ---------------------- |
| `ImmGen`     | 检查是否能够输出与指令类型对应的立即数；是否进行了正确的符号扩展 | 边界值分析             |
| `GPR`        | 检查寄存器是否可以正常读写                                   | 动作桩覆盖             |
| `GPRForward` | 检查能否正常的转发数据                                       | 条件覆盖               |
| `AlgLog`     | 检查是否能够正常地完成算术运算功能，以及是否能够处理溢出和32位运算 | 边界值分析             |
| `MulDiv`     | 检查是否能够正常地完成乘除法运算，以及对特殊情况的处理       | 等价类划分，边界值分析 |
| `CSR`        | 检查寄存器是否可以正常读写                                   | 动作桩覆盖             |
| `CSRCalc`    | 检查是否能够根据控制信号完成输入源数据的输入运算处理         | 判定表                 |

### 控制

| 名称             | 测试内容                              | 测试方法       |
| ---------------- | ------------------------------------- | -------------- |
| `ControlUnit`    | 是否能够生成正确的控制信号            | 理想：穷尽测试 |
| `CSRControlUnit` | 是否能够生成控制`CSR`所需要的控制信号 | 等价类划分     |

### 数据通路

> TODO

## 测试用例

### 模块

#### `ImmGen`

该模块的作用是生成与指令类型对应的立即数。需要测试其正确生成立即数以及是否进行了符号扩展。

| 测试编号 | 测试内容                   | 输入条件                                | 期望结果                    | 实际结果 |
| -------- | -------------------------- | --------------------------------------- | --------------------------- | -------- |
| 1        | 符号扩展<br />I-type立即数 | in：0x1ff8202<br />imm_type：IMM_TYPE_I | imm_out：0xfffffffffffffffc | 通过     |
| 2        | S-type立即数               | in：0x82268<br />imm_type：IMM_TYPE_S   | imm_out：0x48               | 通过     |
| 3        | 符号扩展<br />B-type立即数 | in：0x1fd1321<br />imm_type：IMM_TYPE_B | imm_out：0xffffffffffffffe0 | 通过     |
| 4        | U-type立即数               | in：0x122<br />imm_type：IMM_TYPE_U     | imm_out：0x9000             | 通过     |
| 5        | J-type立即数               | in：0x1eebfe1<br />imm_type：IMM_TYPE_J | imm_out：0xffffffffffffff74 | 通过     |

#### `GPR`

寄存器堆。

| 测试编号 | 测试内容         | 输入条件                                                     | 期望结果                                              | 实际结果 |
| -------- | ---------------- | ------------------------------------------------------------ | ----------------------------------------------------- | -------- |
| 1        | 读端口1          | 初始化，向1号寄存器写入值"h1234".U。然后尝试从读端口1尝试读取该寄存器的值。 | 从读端口1输出的值为"h1234".U，从读端口2读出的值为0。  | 通过     |
| 2        | 读端口2          | 初始化，向3号寄存器写入值"h13456".U。然后尝试从读端口2尝试读取该寄存器的值。 | 从读端口2输出的值为"h13456".U，从读端口1输出的值为0。 | 通过     |
| 3        | 写端口           | 向17号寄存器写入值"h17".U，同时也在该时钟周期在读端口1尝试读取该寄存器的值。 | 读取的值为"h17".U。                                   | 通过     |
| 4        | 写入后两周期再读 | 初始化，向10号寄存器写入"hffff".U，然后从读端口1读取该寄存器的值。在下一个时钟周期的时候，向10号寄存器写入值"h7890".U，但是使能信号为0，同时在读端口1读取10号寄存器的值。 | 两次读取的结果均为"hffff".U。                         | 通过     |
| 5        | 0寄存器写读      | 向0号寄存器写入非0值"hcdcd".U，然后读取0号寄存器。           | 读取出的结果为0。                                     | 通过     |

#### `GPRForward`

该模块的作用是选择正确的转发数据作为源操作数传递给执行阶段。需要检查转发的正确性。

| 测试编号 | 测试内容                 | 输入条件                         | 期望结果 | 实际结果 |
| -------- | ------------------------ | -------------------------------- | -------- | -------- |
| 1        | 默认值                   | 按照转发的优先级设置激活端口的值 | 0.U      | 通过     |
| 2        | 执行阶段算术逻辑单元输出 | 按照转发的优先级设置激活端口的值 | 1.U      | 通过     |
| 3        | 执行阶段snpc的输出       | 按照转发的优先级设置激活端口的值 | 2.U      | 通过     |
| 4        | 访存阶段算术逻辑单元输出 | 按照转发的优先级设置激活端口的值 | 3.U      | 通过     |
| 5        | 访存阶段内存输出         | 按照转发的优先级设置激活端口的值 | 4.U      | 通过     |
| 6        | 访存阶段snpc的输出       | 按照转发的优先级设置激活端口的值 | 5.U      | 通过     |
| 7        | 写回阶段的输出           | 按照转发的优先级设置激活端口的值 | 6.U      | 通过     |

#### `AlgLog`

算术逻辑单元，负责将两个输入数据和控制逻辑相互结合输出正确的运算结果。检查其运算结果是否正确，以及能否正常处理溢出，32位运算。

| 测试编号 | 测试内容 | 输入条件                                                     | 期望结果              | 实际结果 |
| -------- | -------- | ------------------------------------------------------------ | --------------------- | -------- |
| 1        | add      | 输入一：10<br />输入二：-1<br />加法控制逻辑                 | 9                     | 通过     |
| 2        | addw     | 输入一：-2（32位）<br />输入二：1<br />32位加法控制逻辑      | -1（64位）            | 通过     |
| 3        | sub      | 输入一：0<br />输入二：1<br />减法控制逻辑                   | -1（64位）            | 通过     |
| 4        | subw     | 输入一：0（32位，高32位有值）<br />输入二：1<br />32位减法控制逻辑 | -1（64位）            | 通过     |
| 5        | xor      | 输入一：1100（2进制）<br />输入二：1010（2进制）<br />异或控制逻辑 | 0110（2进制）         | 通过     |
| 6        | or       | 输入一：1100（2进制）<br />输入二：1010（2进制）<br />或控制逻辑 | 1110（2进制）         | 通过     |
| 7        | and      | 输入一：1100（2进制）<br />输入二：1010（2进制）<br />与控制逻辑 | 1000（2进制）         | 通过     |
| 8        | slt      | 输入一：-1<br />输入二：0<br />有符号小于控制逻辑            | 1                     | 通过     |
| 9        | sge      | 输入一：-1<br />输入二：0<br />有符号大于等于控制逻辑        | 0                     | 通过     |
| 10       | sltu     | 输入一：-1<br />输入二：0<br />无符号小于控制逻辑            | 0                     | 通过     |
| 11       | sgeu     | 输入一：-1<br />输入二：0<br />无符号大于等于控制逻辑        | 1                     | 通过     |
| 12       | equ      | 输入一：123456<br />输入二：123456<br />等于控制逻辑         | 1                     | 通过     |
| 13       | neq      | 输入一：12345<br />输入二：23456<br />不等于控制逻辑         | 1                     | 通过     |
| 14       | sll      | 输入一：1<br />输入二：2<br />左移控制逻辑                   | 100（2进制）          | 通过     |
| 15       | sllw     | 输入一：0x8000_0000<br />输入二：2<br />32位左移控制逻辑     | 0                     | 通过     |
| 16       | srl      | 输入一：0x8000_0000_0000_0000<br />输入二：2<br />右移控制逻辑 | 0x2000_0000_0000_0000 | 通过     |
| 17       | srlw     | 输入一：0x0000_0001_8000_0000<br />输入二：2<br />32位右移控制逻辑 | 0x0000_0000_2000_0000 | 通过     |
| 18       | sra      | 输入一：0x8000_0000_0000_0000<br />输入二：2<br />算术右移控制逻辑 | 0xe000_0000_0000_0000 | 通过     |
| 19       | sraw     | 输入一：0x0000_0001_8000_0000<br />输入二：2<br />32位右移控制逻辑 | 0xffff_ffff_e000_0000 | 通过     |
| 20       | mova     | 输入一：1<br />输入二：2<br />直传A控制逻辑                  | 1                     | 通过     |
| 21       | movb     | 输入一：1<br />输入二：2<br />直传B控制逻辑                  | 2                     | 通过     |

#### `MulDiv`

该单元的功能是给定两个源操作数，完成对应要求的乘除法运算。测试需要检查是否能够正常地完成乘除法运算，以及对于特殊情况的处理。

| 测试编号 | 测试内容          | 输入条件                                                     | 期望结果              | 实际结果 |
| -------- | ----------------- | ------------------------------------------------------------ | --------------------- | -------- |
| 1        | mul               | src1: 0x2<br />src2: 0x3<br />mul_ctl: MUL_CTL_MUL           | 0x6                   | 通过     |
| 2        | mulh，溢出        | src1: -1<br />src2: 2<br />mul_ctl: MUL_CTL_MULH             | -1                    | 通过     |
| 3        | mulhsu，溢出      | src1: -1<br />src2: 2<br />mul_ctl: MUL_CTL_MULHSU           | -1                    | 通过     |
| 4        | mulhu，无符号溢出 | src1: -1<br />src2: 2<br />mul_ctl: MUL_CTL_MULHU            | 1                     | 通过     |
| 5        | mulw              | src1: -1（32位）<br />src2: 2<br />mul_ctl: MUL_CTL_MULW     | -2                    | 通过     |
| 6        | div，除零         | src1: -1（32位）<br />src2: 0<br />mul_ctl: MUL_CTL_DIV      | -1                    | 通过     |
| 7        | divu              | src1: 0<br />src2: -1<br />mul_ctl: MUL_CTL_DIVU             | 0                     | 通过     |
| 8        | rem，除零         | src1: 0x1000_0000_0000_0001<br />src2: 0<br />mul_ctl: MUL_CTL_REM | 0x1000_0000_0000_0001 | 通过     |
| 9        | remu，溢出        | src1: 0x8000_0000_0000_0000<br />src2: -1<br />mul_ctl: MUL_CTL_REMU | 0x8000_0000_0000_0000 | 通过     |
| 10       | divw，溢出        | src1: 0x8000_0000<br />src2: -1(32位)<br />mul_ctl: MUL_CTL_DIVW | 0x8000_0000           | 通过     |
| 11       | divuw             | src1: 0x8000_0000_1000_0000<br />src2: -1<br />mul_ctl: MUL_CTL_DIVUW | 0                     | 通过     |
| 12       | remw，除零        | src1: 0x8000_0000_1000_0001<br />src2: 0<br />mul_ctl: MUL_CTL_REMW | 0x1000_0001           | 通过     |
| 13       | remuw，高位有值   | src1: 0x1000_0000_0100_0000<br />src2: -1<br />mul_ctl: MUL_CTL_REMUW | 0x0100_0000           | 通过     |

#### `CSR`

控制状态寄存器堆，检测其能否正常读写，以及是否能够对异常情况更新寄存器。

| 测试编号 | 测试内容           | 输入条件                                                     | 期望结果    | 实际结果 |
| -------- | ------------------ | ------------------------------------------------------------ | ----------- | -------- |
| 1        | 写寄存器           | r_addr: mstatus<br />r_en: true.B<br />w_addr: mstatus<br />w_en: true.B<br />w_data: 0x1234 | 0x1234      | 通过     |
| 2        | 写寄存器           | r_addr: mepc<br />r_en: true.B<br />w_addr: mepc<br />w_en: true.B<br />w_data: 0x1234 | 0x1234      | 通过     |
| 3        | 读寄存器           | r_addr: mstatus<br />r_en: true.B<br />w_addr: mepc<br />w_en: true.B<br />w_data: 0x1234 | 0xa00001800 | 通过     |
| 4        | 异常状态下寄存器读 | r_addr: mepc<br />r_en: true.B<br />expt_op: true.B<br />pc: 0x80001000 | 0x80001000  | 通过     |

#### `CSRCalc`

该模块的作用是根据输入的控制信号，完成对两个源操作数对应的运算要求。测试时检查输出结果是否与要求运算的结果相符。

| 测试编号 | 测试内容         | 输入条件                                             | 期望结果 | 实际结果 |
| -------- | ---------------- | ---------------------------------------------------- | -------- | -------- |
| 1        | 默认非法操作情况 | src: b1100<br />csr_data: b1010<br />csr_op_ctl: b00 | 0        | 通过     |
| 2        | 读写操作         | src: b1100<br />csr_data: b1010<br />csr_op_ctl: b00 | b1100    | 通过     |
| 3        | 置位操作         | src: b1100<br />csr_data: b1010<br />csr_op_ctl: b00 | b1110    | 通过     |
| 4        | 清位操作         | src: b1100<br />csr_data: b1010<br />csr_op_ctl: b00 | b1000    | 通过     |

### 控制

#### `ControlUnit`

控制单元主要就根据输入的指令来生成指令需要的控制信号。需要测试其能否正确译码出指令需要的控制信号。由于穷尽测试较为复杂，这里先以指令的类型各选择一个来进行测试。

| 测试编号 | 测试内容  | 输入条件          | 期望结果                             | 实际结果 |
| -------- | --------- | ----------------- | ------------------------------------ | -------- |
| 1        | U类型指令 | lui：0xb7         | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 2        | R类型指令 | sub：0x40178ab3   | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 3        | S类型指令 | sh：0xf41023      | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 4        | I类型指令 | sraiw：0x4185551b | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 5        | J类型指令 | jal：0xf01ff0ef   | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 6        | B类型指令 | bge：0xe6d663     | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 7        | 无效指令  | 0                 | 无效指令对应的控制信号               | 通过     |

#### `CSRControlUnit`

该模块生成`CSR`模块所需要的控制信号。需要测试其能否根据输入的条件来判断是否可以生成对应的信号。

| 测试编号 | 测试内容                 | 输入条件                                              | 期望结果                                                     | 实际结果 |
| -------- | ------------------------ | ----------------------------------------------------- | ------------------------------------------------------------ | -------- |
| 1        | 当为一条CSR指令时        | zicsr_op: true.B<br />rd: 1<br />rs1: 1<br />funct: 1 | csr_r_en: true.B<br />csr_w_en: true.B<br />csr_src_ctl: false.B<br />csr_op_ctl: 1 | 通过     |
| 2        | 当不为一条CSR指令时      | zicsr_op: true.B<br />rd: 1<br />rs1: 1<br />funct: 2 | csr_r_en: false.B<br />csr_w_en: false.B<br />csr_src_ctl: false.B<br />csr_op_ctl: 2 | 通过     |
| 3        | rd为0的输入条件，读使能  | zicsr_op: true.B<br />rd: 0<br />rs1: 1<br />funct: 3 | csr_r_en: false.B<br />csr_w_en: true.B<br />csr_src_ctl: false.B<br />csr_op_ctl: 3 | 通过     |
| 4        | rs1为0的输入条件，写使能 | zicsr_op: true.B<br />rd: 1<br />rs1: 0<br />funct: 5 | csr_r_en: true.B<br />csr_w_en: false.B<br />csr_src_ctl: true.B<br />csr_op_ctl: 1 | 通过     |

### 数据通路

> TODO

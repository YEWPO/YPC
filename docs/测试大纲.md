# 测试大纲

## 测试目的

通过单元测试和集成测试，尽最大可能保证局部模板的正确性，进而使整个设计正确，满足设计功能需求和处理器的使用需求。

## 测试模块

首先，`NPC`的微架构设计中，将其分为控制层，冒险层和数据通路层三个层面，即需要对这三个层面进行测试。其次，模块电路(`utils`文件夹中)是构成这三层的最小单元，应当对其进行仔细的单元测试。

### 模块

| 名称       | 测试内容                                                     | 测试方法   |
| ---------- | ------------------------------------------------------------ | ---------- |
| `ImmGen`   | 检查是否能够输出与指令类型对应的立即数；是否进行了正确的符号扩展 | 边界值分析 |
| `Register` | 检查寄存器是否可以正常读写                                   | 动作桩覆盖 |
|            |                                                              |            |

### 控制

控制模块仅有`ControlUnit`模块，其作用为根据输入的指令产生对应指令需要的控制信号。测试需要检查其生成的控制信号是否与对应的指令对应。理想的测试方法，穷尽测试。

### 冒险

### 数据通路

| 名称             | 测试内容                                                     | 测试方法         |
| ---------------- | ------------------------------------------------------------ | ---------------- |
| `InstFetchUnit`  | 检查其是否能根据使能信号对寄存器的值更新（由于该单元具有DPI-C部分，故无法对这一部分进行测试） | 集成，条件覆盖   |
| `InstDecodeUnit` | 检查单元的输出是否符合当前指令预期期望的译码结果，同时检查使能和重置信号 | 集成测试，AD测试 |
|                  |                                                              |                  |

## 测试用例

### 模块

#### `ImmGen`

该模块的作用是生成与指令类型对应的立即数。需要测试其正确生成立即数以及是否进行了符号扩展。

| 测试编号 | 测试内容                   | 输入条件                                | 期望结果                    | 实际结果 |
| -------- | -------------------------- | --------------------------------------- | --------------------------- | -------- |
| 1        | 符号扩展<br />I-type立即数 | in：0x1ff8202<br />imm_type：IMM_TYPE_I | imm_out：0xfffffffffffffffc | 通过     |
| 2        | S-type立即数               | in：0x82268<br />imm_type：IMM_TYPE_S   | imm_out：0x48               | 通过     |
| 3        | 符号扩展<br />B-type立即数 | in：0x1fd1321<br />imm_type：IMM_TYPE_B | imm_out：0xffffffffffffffe0 | 通过     |
| 4        | U-type立即数               | in：0x122<br />imm_type：IMM_TYPE_U     | imm_out：0x9000             | 通过     |
| 5        | J-type立即数               | in：0x1eebfe1<br />imm_type：IMM_TYPE_J | imm_out：0xffffffffffffff74 | 通过     |

#### `Register`

寄存器堆。

| 测试编号 | 测试内容         | 输入条件                                                     | 期望结果                                              | 实际结果 |
| -------- | ---------------- | ------------------------------------------------------------ | ----------------------------------------------------- | -------- |
| 1        | 读端口1          | 初始化，向1号寄存器写入值"h1234".U。然后尝试从读端口1尝试读取该寄存器的值。 | 从读端口1输出的值为"h1234".U，从读端口2读出的值为0。  | 通过     |
| 2        | 读端口2          | 初始化，向3号寄存器写入值"h13456".U。然后尝试从读端口2尝试读取该寄存器的值。 | 从读端口2输出的值为"h13456".U，从读端口1输出的值为0。 | 通过     |
| 3        | 写端口           | 向17号寄存器写入值"h17".U，同时也在该时钟周期在读端口1尝试读取该寄存器的值。 | 读取的值为"h17".U。                                   | 通过     |
| 4        | 写入后两周期再读 | 初始化，向10号寄存器写入"hffff".U，然后从读端口1读取该寄存器的值。在下一个时钟周期的时候，向10号寄存器写入值"h7890".U，但是使能信号为0，同时在读端口1读取10号寄存器的值。 | 两次读取的结果均为"hffff".U。                         | 通过     |
| 5        | 0寄存器写读      | 向0号寄存器写入非0值"hcdcd".U，然后读取0号寄存器。           | 读取出的结果为0。                                     | 通过     |

### 控制

### 冒险

### 数据通路

#### `InstFetchUnit`

| 测试编号 | 测试内容 | 输入条件         | 期望结果                   | 实际结果 |
| -------- | -------- | ---------------- | -------------------------- | -------- |
| 1        | 使能     | 使能信号为高电平 | pc寄存器输出了更新后的结果 | 通过     |
| 2        | 使能     | 使能信号为低电平 | pc寄存器仍然保持之前结果   | 通过     |

#### `InstDecodeUnit`

| 测试编号 | 测试内容   | 输入条件                                                     | 期望结果                                                   | 实际结果 |
| -------- | ---------- | ------------------------------------------------------------ | ---------------------------------------------------------- | -------- |
| 1        | 重置，使能 | 使能信号为高电平，重置信号为高电平                           | pc寄存器的值被更新为0，或者是未发生变化（如果初始值为0且） | 通过     |
| 2        | 重置，使能 | 使能信号为高电平，重置信号为低电平                           | pc寄存器的值被更新为输入的值                               | 通过     |
| 3        | 使能       | 初始化将寄存器的值更新为其他值，然后使能信号为低电平，重置信号为低电平 | pc寄存器的值未更新                                         | 通过     |


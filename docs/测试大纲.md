# 测试大纲

## 测试目的

通过单元测试和集成测试，尽最大可能保证局部模板的正确性，进而使整个设计正确，满足设计功能需求和处理器的使用需求。

## 测试模块

首先，`NPC`的微架构设计中，将其分为控制层，冒险层和数据通路层三个层面，即需要对这三个层面进行测试。其次，模块电路(`utils`文件夹中)是构成这三层的最小单元，应当对其进行仔细的单元测试。

### 模块

| 名称       | 测试内容                                                     | 测试方法               |
| ---------- | ------------------------------------------------------------ | ---------------------- |
| `ImmGen`   | 检查是否能够输出与指令类型对应的立即数；是否进行了正确的符号扩展 | 边界值分析             |
| `Register` | 检查寄存器是否可以正常读写                                   | 动作桩覆盖             |
| `Forward`  | 检查能否正常的转发数据                                       | 条件覆盖               |
| `AlgLog`   | 检查是否能够正常地完成算术运算功能，以及是否能够处理溢出和32位运算 | 边界值分析             |
| `MulDiv`   | 检查是否能够正常地完成乘除法运算，以及对特殊情况的处理       | 等价类划分，边界值分析 |
| `CSR`      | 检查寄存器是否可以正常读写                                   | 动作桩覆盖             |

### 控制

| 名称             | 测试内容                              | 测试方法       |
| ---------------- | ------------------------------------- | -------------- |
| `ControlUnit`    | 是否能够生成正确的控制信号            | 理想：穷尽测试 |
| `CSRControlUnit` | 是否能够生成控制`CSR`所需要的控制信号 | 等价类划分     |

### 冒险

| 名称            | 测试内容                                                     | 测试方法     |
| --------------- | ------------------------------------------------------------ | ------------ |
| `HazardUnit`    | 是否能够根据输入的条件来决定流水线的状态以及对选择转发数据的控制 | AD测试       |
| `CSRHazardUnit` | 是否能够根据`CSR`输入的状态来决定流水线的状态以及对`CSR`的转发数据的控制 | 条件覆盖测试 |

### 数据通路

| 名称             | 测试内容                                                     | 测试方法               |
| ---------------- | ------------------------------------------------------------ | ---------------------- |
| `InstFetchUnit`  | 检查其是否能根据使能信号对寄存器的值更新                     | 集成测试，条件覆盖测试 |
| `InstDecodeUnit` | 检查单元的输出是否符合当前指令预期期望的译码结果，同时检查使能和重置信号。同时，随机检查个别指令的译码结果是否正确 | 集成测试，AD测试       |
| `ExecuteUnit`    | 检查是否得到运算结果和下一跳地址，以及跳转信号               | AD测试                 |
| `LoadStoreUnit`  | 由于该模块涉及DPI-C，暂时的能力无法对该模块进行测试          |                        |
| `WriteBackUnit`  | 检查该模块的一个选择器工作是否正确                           | 条件覆盖测试           |

## 测试用例

### 模块

#### `ImmGen`

该模块的作用是生成与指令类型对应的立即数。需要测试其正确生成立即数以及是否进行了符号扩展。

| 测试编号 | 测试内容                   | 输入条件                                | 期望结果                    | 实际结果 |
| -------- | -------------------------- | --------------------------------------- | --------------------------- | -------- |
| 1        | 符号扩展<br />I-type立即数 | in：0x1ff8202<br />imm_type：IMM_TYPE_I | imm_out：0xfffffffffffffffc | 通过     |
| 2        | S-type立即数               | in：0x82268<br />imm_type：IMM_TYPE_S   | imm_out：0x48               | 通过     |
| 3        | 符号扩展<br />B-type立即数 | in：0x1fd1321<br />imm_type：IMM_TYPE_B | imm_out：0xffffffffffffffe0 | 通过     |
| 4        | U-type立即数               | in：0x122<br />imm_type：IMM_TYPE_U     | imm_out：0x9000             | 通过     |
| 5        | J-type立即数               | in：0x1eebfe1<br />imm_type：IMM_TYPE_J | imm_out：0xffffffffffffff74 | 通过     |

#### `Register`

寄存器堆。

| 测试编号 | 测试内容         | 输入条件                                                     | 期望结果                                              | 实际结果 |
| -------- | ---------------- | ------------------------------------------------------------ | ----------------------------------------------------- | -------- |
| 1        | 读端口1          | 初始化，向1号寄存器写入值"h1234".U。然后尝试从读端口1尝试读取该寄存器的值。 | 从读端口1输出的值为"h1234".U，从读端口2读出的值为0。  | 通过     |
| 2        | 读端口2          | 初始化，向3号寄存器写入值"h13456".U。然后尝试从读端口2尝试读取该寄存器的值。 | 从读端口2输出的值为"h13456".U，从读端口1输出的值为0。 | 通过     |
| 3        | 写端口           | 向17号寄存器写入值"h17".U，同时也在该时钟周期在读端口1尝试读取该寄存器的值。 | 读取的值为"h17".U。                                   | 通过     |
| 4        | 写入后两周期再读 | 初始化，向10号寄存器写入"hffff".U，然后从读端口1读取该寄存器的值。在下一个时钟周期的时候，向10号寄存器写入值"h7890".U，但是使能信号为0，同时在读端口1读取10号寄存器的值。 | 两次读取的结果均为"hffff".U。                         | 通过     |
| 5        | 0寄存器写读      | 向0号寄存器写入非0值"hcdcd".U，然后读取0号寄存器。           | 读取出的结果为0。                                     | 通过     |

#### `Forward`

该模块的作用是选择正确的转发数据作为源操作数传递给执行阶段。需要检查转发的正确性。

| 测试编号 | 测试内容                 | 输入条件                         | 期望结果 | 实际结果 |
| -------- | ------------------------ | -------------------------------- | -------- | -------- |
| 1        | 默认值                   | 按照转发的优先级设置激活端口的值 | 0.U      | 通过     |
| 2        | 执行阶段算术逻辑单元输出 | 按照转发的优先级设置激活端口的值 | 1.U      | 通过     |
| 3        | 执行阶段snpc的输出       | 按照转发的优先级设置激活端口的值 | 2.U      | 通过     |
| 4        | 访存阶段算术逻辑单元输出 | 按照转发的优先级设置激活端口的值 | 3.U      | 通过     |
| 5        | 访存阶段内存输出         | 按照转发的优先级设置激活端口的值 | 4.U      | 通过     |
| 6        | 访存阶段snpc的输出       | 按照转发的优先级设置激活端口的值 | 5.U      | 通过     |
| 7        | 写回阶段的输出           | 按照转发的优先级设置激活端口的值 | 6.U      | 通过     |

#### `AlgLog`

算术逻辑单元，负责将两个输入数据和控制逻辑相互结合输出正确的运算结果。检查其运算结果是否正确，以及能否正常处理溢出，32位运算。

| 测试编号 | 测试内容 | 输入条件                                                     | 期望结果              | 实际结果 |
| -------- | -------- | ------------------------------------------------------------ | --------------------- | -------- |
| 1        | add      | 输入一：10<br />输入二：-1<br />加法控制逻辑                 | 9                     | 通过     |
| 2        | addw     | 输入一：-2（32位）<br />输入二：1<br />32位加法控制逻辑      | -1（64位）            | 通过     |
| 3        | sub      | 输入一：0<br />输入二：1<br />减法控制逻辑                   | -1（64位）            | 通过     |
| 4        | subw     | 输入一：0（32位，高32位有值）<br />输入二：1<br />32位减法控制逻辑 | -1（64位）            | 通过     |
| 5        | xor      | 输入一：1100（2进制）<br />输入二：1010（2进制）<br />异或控制逻辑 | 0110（2进制）         | 通过     |
| 6        | or       | 输入一：1100（2进制）<br />输入二：1010（2进制）<br />或控制逻辑 | 1110（2进制）         | 通过     |
| 7        | and      | 输入一：1100（2进制）<br />输入二：1010（2进制）<br />与控制逻辑 | 1000（2进制）         | 通过     |
| 8        | slt      | 输入一：-1<br />输入二：0<br />有符号小于控制逻辑            | 1                     | 通过     |
| 9        | sge      | 输入一：-1<br />输入二：0<br />有符号大于等于控制逻辑        | 0                     | 通过     |
| 10       | sltu     | 输入一：-1<br />输入二：0<br />无符号小于控制逻辑            | 0                     | 通过     |
| 11       | sgeu     | 输入一：-1<br />输入二：0<br />无符号大于等于控制逻辑        | 1                     | 通过     |
| 12       | equ      | 输入一：123456<br />输入二：123456<br />等于控制逻辑         | 1                     | 通过     |
| 13       | neq      | 输入一：12345<br />输入二：23456<br />不等于控制逻辑         | 1                     | 通过     |
| 14       | sll      | 输入一：1<br />输入二：2<br />左移控制逻辑                   | 100（2进制）          | 通过     |
| 15       | sllw     | 输入一：0x8000_0000<br />输入二：2<br />32位左移控制逻辑     | 0                     | 通过     |
| 16       | srl      | 输入一：0x8000_0000_0000_0000<br />输入二：2<br />右移控制逻辑 | 0x2000_0000_0000_0000 | 通过     |
| 17       | srlw     | 输入一：0x0000_0001_8000_0000<br />输入二：2<br />32位右移控制逻辑 | 0x0000_0000_2000_0000 | 通过     |
| 18       | sra      | 输入一：0x8000_0000_0000_0000<br />输入二：2<br />算术右移控制逻辑 | 0xe000_0000_0000_0000 | 通过     |
| 19       | sraw     | 输入一：0x0000_0001_8000_0000<br />输入二：2<br />32位右移控制逻辑 | 0xffff_ffff_e000_0000 | 通过     |
| 20       | mova     | 输入一：1<br />输入二：2<br />直传A控制逻辑                  | 1                     | 通过     |
| 21       | movb     | 输入一：1<br />输入二：2<br />直传B控制逻辑                  | 2                     | 通过     |

#### `MulDiv`

该单元的功能是给定两个源操作数，完成对应要求的乘除法运算。测试需要检查是否能够正常地完成乘除法运算，以及对于特殊情况的处理。

| 测试编号 | 测试内容          | 输入条件                                                     | 期望结果              | 实际结果 |
| -------- | ----------------- | ------------------------------------------------------------ | --------------------- | -------- |
| 1        | mul               | src1: 0x2<br />src2: 0x3<br />mul_ctl: MUL_CTL_MUL           | 0x6                   | 通过     |
| 2        | mulh，溢出        | src1: -1<br />src2: 2<br />mul_ctl: MUL_CTL_MULH             | -1                    | 通过     |
| 3        | mulhsu，溢出      | src1: -1<br />src2: 2<br />mul_ctl: MUL_CTL_MULHSU           | -1                    | 通过     |
| 4        | mulhu，无符号溢出 | src1: -1<br />src2: 2<br />mul_ctl: MUL_CTL_MULHU            | 1                     | 通过     |
| 5        | mulw              | src1: -1（32位）<br />src2: 2<br />mul_ctl: MUL_CTL_MULW     | -2                    | 通过     |
| 6        | div，除零         | src1: -1（32位）<br />src2: 0<br />mul_ctl: MUL_CTL_DIV      | -1                    | 通过     |
| 7        | divu              | src1: 0<br />src2: -1<br />mul_ctl: MUL_CTL_DIVU             | 0                     | 通过     |
| 8        | rem，除零         | src1: 0x1000_0000_0000_0001<br />src2: 0<br />mul_ctl: MUL_CTL_REM | 0x1000_0000_0000_0001 | 通过     |
| 9        | remu，溢出        | src1: 0x8000_0000_0000_0000<br />src2: -1<br />mul_ctl: MUL_CTL_REMU | 0x8000_0000_0000_0000 | 通过     |
| 10       | divw，溢出        | src1: 0x8000_0000<br />src2: -1(32位)<br />mul_ctl: MUL_CTL_DIVW | 0x8000_0000           | 通过     |
| 11       | divuw             | src1: 0x8000_0000_1000_0000<br />src2: -1<br />mul_ctl: MUL_CTL_DIVUW | 0                     | 通过     |
| 12       | remw，除零        | src1: 0x8000_0000_1000_0001<br />src2: 0<br />mul_ctl: MUL_CTL_REMW | 0x1000_0001           | 通过     |
| 13       | remuw，高位有值   | src1: 0x1000_0000_0100_0000<br />src2: -1<br />mul_ctl: MUL_CTL_REMUW | 0x0100_0000           | 通过     |

#### `CSR`

控制状态寄存器堆，检测其能否正常读写，以及是否能够对异常情况更新寄存器。

| 测试编号 | 测试内容           | 输入条件                                                     | 期望结果    | 实际结果 |
| -------- | ------------------ | ------------------------------------------------------------ | ----------- | -------- |
| 1        | 写寄存器           | r_addr: mstatus<br />r_en: true.B<br />w_addr: mstatus<br />w_en: true.B<br />w_data: 0x1234 | 0x1234      | 通过     |
| 2        | 写寄存器           | r_addr: mepc<br />r_en: true.B<br />w_addr: mepc<br />w_en: true.B<br />w_data: 0x1234 | 0x1234      | 通过     |
| 3        | 读寄存器           | r_addr: mstatus<br />r_en: true.B<br />w_addr: mepc<br />w_en: true.B<br />w_data: 0x1234 | 0xa00001800 | 通过     |
| 4        | 异常状态下寄存器读 | r_addr: mepc<br />r_en: true.B<br />expt_op: true.B<br />pc: 0x80001000 | 0x80001000  | 通过     |

### 控制

#### `ControlUnit`

控制单元主要就根据输入的指令来生成指令需要的控制信号。需要测试其能否正确译码出指令需要的控制信号。由于穷尽测试较为复杂，这里先以指令的类型各选择一个来进行测试。

| 测试编号 | 测试内容  | 输入条件          | 期望结果                             | 实际结果 |
| -------- | --------- | ----------------- | ------------------------------------ | -------- |
| 1        | U类型指令 | lui：0xb7         | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 2        | R类型指令 | sub：0x40178ab3   | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 3        | S类型指令 | sh：0xf41023      | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 4        | I类型指令 | sraiw：0x4185551b | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 5        | J类型指令 | jal：0xf01ff0ef   | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 6        | B类型指令 | bge：0xe6d663     | 在控制信号表中与该指令对应的控制信号 | 通过     |
| 7        | 无效指令  | 0                 | 无效指令对应的控制信号               | 通过     |

#### `CSRControlUnit`

该模块生成`CSR`模块所需要的控制信号。需要测试其能否根据输入的条件来判断是否可以生成对应的信号。

| 测试编号 | 测试内容                 | 输入条件                                              | 期望结果                                                     | 实际结果 |
| -------- | ------------------------ | ----------------------------------------------------- | ------------------------------------------------------------ | -------- |
| 1        | 当为一条CSR指令时        | zicsr_op: true.B<br />rd: 1<br />rs1: 1<br />funct: 1 | csr_r_en: true.B<br />csr_w_en: true.B<br />csr_src_ctl: false.B<br />csr_op_ctl: 1 | 通过     |
| 2        | 当不为一条CSR指令时      | zicsr_op: true.B<br />rd: 1<br />rs1: 1<br />funct: 2 | csr_r_en: false.B<br />csr_w_en: false.B<br />csr_src_ctl: false.B<br />csr_op_ctl: 2 | 通过     |
| 3        | rd为0的输入条件，读使能  | zicsr_op: true.B<br />rd: 0<br />rs1: 1<br />funct: 3 | csr_r_en: false.B<br />csr_w_en: true.B<br />csr_src_ctl: false.B<br />csr_op_ctl: 3 | 通过     |
| 4        | rs1为0的输入条件，写使能 | zicsr_op: true.B<br />rd: 1<br />rs1: 0<br />funct: 5 | csr_r_en: true.B<br />csr_w_en: false.B<br />csr_src_ctl: true.B<br />csr_op_ctl: 1 | 通过     |

### 冒险

#### `HazardUnit`

冒险单元将根据输入的各个流水阶段的状态信息来决定是否要暂停或者冒泡某个阶段，以及决定是否要接受转发的数据。需要测试其能否根据输入的状态信息来生成正确的暂停，冒险的控制信号，以及转发的控制信号。

在该测试中，输入条件有`rs1`，`rs2`，`rd_E`，`rd_M`，`rd_W`五个输入条件。有`enable_F`，`enable_D`，`reset_D`，`reset_E`，`fa_ctl`，`fb_ctl`输出条件。我们对输入条件可能存在的情况进行组合测试，输入条件可能的情况如下：

![image-20230801122024796](https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20230801122024796.png)

同时，我们还需要检查其**多个条件满足的优先级**的处理是否正确，然后对**源寄存器为0**的情况进行测试。

<blockquote alt="danger">
  <h4>注意</h4>
  <p>
    以下测试源寄存器和目的寄存器均有效。
  </p>
</blockquote>

| 测试 编号 | 测试内容                                 | 输入条件                                                     | 期望结果                                                     | 实际结果 |
| --------- | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1         | 无冲突，不需要访存                       | rs1 = 0, rs2 = 1, rd_E = 2, rd_M = 3, rd_W  = 4, wb_ctl_E = WB_CTL_ALU, wb_ctl_M = WB_CTL_MEM, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_DEFAULT | 通过     |
| 2         | 有冲突，需要访存                         | rs1 = 11, rs2 = 12, rd_E = 11, rd_M = 13,  rd_W = 14, wb_ctl_E = WB_CTL_MEM wb_ctl_M = WB_CTL_MEM, jump_sig = false | enable_F = false, enable_D = false, reset_D = false, reset_E = true, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_DEFAULT | 通过     |
| 3         | 有冲突，不需要访存                       | rs1 = 21, rs2 = 22, rd_E = 22, rd_M = 23,  rd_W = 14, wb_ctl_E = WB_CTL_ALU,  wb_ctl_M = WB_CTL_MEM, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_ALU_E | 通过     |
| 4         | 有冲突，不需要访存                       | rs1 = 17, rs2 = 10, rd_E = 11, rd_M = 17,  rd_W = 14, wb_ctl_E = WB_CTL_ALU,  wb_ctl_M = WB_CTL_MEM, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_MEM_M, fb_ctl = F_CTL_DEFAULT | 通过     |
| 5         | 有冲突，不需要访存                       | rs1 = 7, rs2 = 2, rd_E = 11, rd_M = 17,  rd_W = 2,  wb_ctl_E = WB_CTL_ALU,  wb_ctl_M = WB_CTL_MEM, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_WB_DATA | 通过     |
| 6         | 有多个冲突                               | rs1 = 31, rs2 = 5, rd_E = 11, rd_M = 31,  rd_W = 31,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_SNPC_M, fb_ctl = F_CTL_DEFAULT | 通过     |
| 7         | 与两个源寄存器冲突，在不同阶段           | rs1 = 13, rs2 = 15, rd_E = 13, rd_M = 31,  rd_W = 15,  wb_ctl_E = WB_CTL_SNPC,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_SNPC_E, fb_ctl = F_CTL_WB_DATA | 通过     |
| 8         | 与两个源寄存器冲突，在不同阶段，需要访存 | rs1 = 13, rs2 = 15, rd_E = 13, rd_M = 31,  rd_W = 15,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false | enable_F = false, enable_D = false, reset_D = false, reset_E = true, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_WB_DATA | 通过     |
| 9         | 与两个源寄存器冲突，在相同阶段           | rs1 = 15, rs2 = 15, rd_E = 11, rd_M = 15,  rd_W = 9,  wb_ctl_E = WB_CTL_ALU,  wb_ctl_M = WB_CTL_ALU, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_ALU_M, fb_ctl = F_CTL_ALU_M | 通过     |
| 10        | 有冲突，但冲突寄存器为0                  | rs1 = 0, rs2 = 15, rd_E = 0, rd_M = 0,  rd_W = 0,  wb_ctl_E = WB_CTL_ALU,  wb_ctl_M = WB_CTL_ALU, jump_sig = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_DEFAULT | 通过     |

对于控制冒险的测试，当存在需要跳转的时候，暂停和冒泡的控制信号正确。

<blockquote alt="danger">
  <h4>注意</h4>
  <p>
    以下测试源寄存器和目的寄存器均有效。
  </p>
</blockquote>

| 测试编号 | 测试内容           | 输入条件                                                     | 期望结果                                                     | 实际结果 |
| -------- | ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1        | 如果存在跳转的情况 | rs1 = 31, rs2 = 5, rd_E = 11, rd_M = 31,  rd_W = 31,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = true | enable_F = true, enable_D = true, reset_D = true, reset_E = true, fa_ctl  = F_CTL_SNPC_M, fb_ctl = F_CTL_DEFAULT | 通过     |

对于源寄存器和目的寄存器存在无效的情况的测试如下：

| 测试编号 | 测试内容                     | 输入条件                                                     | 期望结果                                                     | 实际结果 |
| -------- | ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1        | rs1, rs2有效，但是存在rd无效 | rs1 = 31, rs2 = 5, rd_E = 31, rd_M = 31,  rd_W = 31,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false<br />rs1_tag=true, rs2_tag = true, rd_tag_E = false, rd_tag_M = true, rd_tag_W = true | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_SNPC_M, fb_ctl = F_CTL_DEFAULT | 通过     |
| 2        | rs1, rs2有效，但是rd无效     | rs1 = 31, rs2 = 5, rd_E = 31, rd_M = 31,  rd_W = 31,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false<br />rs1_tag=true, rs2_tag = true, rd_tag_E = false, rd_tag_M = false, rd_tag_W = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_DEFAULT | 通过     |
| 3        | rs1, rs2无效，但是rd有效     | rs1 = 31, rs2 = 5, rd_E = 31, rd_M = 31,  rd_W = 31,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false<br />rs1_tag=false, rs2_tag = true, rd_tag_E = true, rd_tag_M = true, rd_tag_W = true | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_DEFAULT | 通过     |
| 4        | rs1, rs2, rd均无效           | rs1 = 31, rs2 = 5, rd_E = 31, rd_M = 31,  rd_W = 31,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false<br />rs1_tag=false, rs2_tag = false, rd_tag_E = false, rd_tag_M = false, rd_tag_W = false | enable_F = true, enable_D = true, reset_D = false, reset_E = false, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_DEFAULT | 通过     |
| 5        | rs1有效, rs2无效, rd均有效   | rs1 = 31, rs2 = 31, rd_E = 31, rd_M = 31,  rd_W = 31,  wb_ctl_E = WB_CTL_MEM,  wb_ctl_M = WB_CTL_SNPC, jump_sig = false<br />rs1_tag=true, rs2_tag = false, rd_tag_E = true, rd_tag_M = true, rd_tag_W = true | enable_F = false, enable_D = false, reset_D = false, reset_E = true, fa_ctl  = F_CTL_DEFAULT, fb_ctl = F_CTL_DEFAULT | 通过     |

<blockquote alt="warn">
  <h4>注意</h4>
  <p>
    附带发现的`bug`，当执行阶段发生冲突且需要访存时，同时也存在访存或者是写回时发生冲突时，转发控制信号会变成访存或者是写回时的冲突情况，实际上是不进行操作的。
  </p>
</blockquote>
#### `CSRHazardUnit`

该模块控制`CSR`的数据转发，以及根据`CSR`的状态决定是否要修改流水线的状态。通过对可能的条件的覆盖来测试该冒险模块。

对转发的测试：

> 假设所有的寄存器在当前阶段均有效

| 测试编号 | 测试内容     | 输入条件                            | 期望结果      | 实际结果 |
| -------- | ------------ | ----------------------------------- | ------------- | -------- |
| 1        | 无冒险情况   | 后3个阶段的寄存器编号和译码阶段不同 | csr_fw_ctl: 0 | 通过     |
| 2        | 执行阶段冲突 | 后3个阶段的寄存器编号和译码阶段相同 | csr_fw_ctl: 1 | 通过     |
| 3        | 访存阶段冲突 | 后2个阶段的寄存器编号与译码阶段相同 | csr_fw_ctl: 2 | 通过     |
| 4        | 写回阶段冲突 | 后2个阶段的寄存器编号与译码阶段相同 | csr_fw_ctl: 3 | 通过     |

对异常情况下的流水线的控制测试：

| 测试编号 | 测试内容          | 输入条件                                | 期望结果         | 实际结果 |
| -------- | ----------------- | --------------------------------------- | ---------------- | -------- |
| 1        | 非ecall和mret指令 | ecall_op: false.B<br />mret_op: false.B | expt_op: false.B | 通过     |
| 2        | 是ecall或mret指令 | ecall_op: false.B<br />mret_op: true.B  | expt_op: true.B  | 通过     |

### 数据通路

#### `InstFetchUnit`

该阶段的作用是，根据`PC`值取出正确的指令。由于涉及到内联`verilog`以及仿真，这里就只对使能信号进行测试。

| 测试编号 | 测试内容 | 输入条件         | 期望结果                   | 实际结果 |
| -------- | -------- | ---------------- | -------------------------- | -------- |
| 1        | 使能     | 使能信号为高电平 | pc寄存器输出了更新后的结果 | 通过     |
| 2        | 使能     | 使能信号为低电平 | pc寄存器仍然保持之前结果   | 通过     |

#### `InstDecodeUnit`

该阶段的作用是，根据输入的指令，生成对应的立即数，或者是访问寄存器堆得到对应的源操作数。然后，生成对应的控制信号。主要测试其生成的源操作数是否正确，以及控制信号是否正确。

| 测试编号 | 测试内容   | 输入条件                                                     | 期望结果                                                   | 实际结果 |
| -------- | ---------- | ------------------------------------------------------------ | ---------------------------------------------------------- | -------- |
| 1        | 重置，使能 | 使能信号为高电平，重置信号为高电平                           | pc寄存器的值被更新为0，或者是未发生变化（如果初始值为0且） | 通过     |
| 2        | 重置，使能 | 使能信号为高电平，重置信号为低电平                           | pc寄存器的值被更新为输入的值                               | 通过     |
| 3        | 使能       | 初始化将寄存器的值更新为其他值，然后使能信号为低电平，重置信号为低电平 | pc寄存器的值未更新                                         | 通过     |

之后，对该阶段做集成测试，测试其中的控制逻辑单元，寄存器堆，转发选择器以及立即数生成器组合工作下是否可以正常工作，输出正确的结果。由于各个模块在此之前已经做过比较详尽的测试，这里采用选择一个之前没有测试过的一组数据，作为输入进行测试。

| 测试内容                                                     | 输入条件                                               | 期望结果                                                     | 实际结果 |
| ------------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 控制逻辑单元<br />寄存器堆<br />转发选择器<br />立即数生成器 | ld指令：0x02813083。同时，对sp寄存器初始化为0x80000378 | 立即数等于40，寄存器1读取值为0x8000738。控制信号符合该指令对应的控制信号 | 通过     |

#### `ExecuteUnit`

该阶段对输入的输入的数据进行运算处理，得到计算的结果，并且需要计算下一跳的`PC`以及是否需要跳转。通过`AD`测试，检查其是否可以正确计算出结果，以及产生动态下一跳的地址。

| 测试编号 | 测试内容                  | 输入条件                                                     | 期望结果                                                     | 实际结果 |
| -------- | ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1        | sraiw一条常规指令         | r_data1：0x8000_0000<br />r_data2：2<br />imm：b110000<br />dnpc_ctl：DNPC_CTL_DEFAULT<br />a_ctl：A_CTL_SRC1<br />b_ctl：B_CTL_IMM<br />pc：0x8000_0010<br />jump_op：JUMP_OP_DEFAULT<br />alu_ctl = ALU_CTL_SRAW | jump_ctl：false<br />dnpc：0x8000_0040<br />alu_out = 0xffff_8000 | 通过     |
| 2        | bne跳转指令，但是跳转失败 | r_data1：0x1<br />r_data2：0x1<br />imm：0x10<br />dnpc_ctl：DNPC_CTL_PC<br />a_ctl：A_CTL_SRC1<br />b_ctl：B_CTL_SRC2<br />pc：0x8000_0200<br />jump_op：JUMP_OP_BRANCE<br />alu_ctl：ALU_CTL_NEQ | jump_ctl = false<br />dnpc：0x8000_0210<br />alu_out = 0     | 通过     |
| 3        | bge跳转指令，跳转成功     | r_data1：0x1<br />r_data2：0x1<br />imm：0x10<br />dnpc_ctl：DNPC_CTL_PC<br />a_ctl：A_CTL_SRC1<br />b_ctl：B_CTL_SRC2<br />pc：0x8000_0200<br />jump_op：JUMP_OP_BRANCH<br />alu_ctl：ALU_CTL_SGE | jump_ctl = true<br />dnpc：0x8000_0210<br />alu_out = 1      | 通过     |
| 4        | jalr跳转指令              | r_data1：0x8000_0000<br />r_data2：0x1<br />imm：JUMP_OP_JAL<br />dnpc_ctl：DNPC_CTL_SRC2<br />pc：0x8000_0200<br />jump_op：b01 | jump_ctl = true<br />dnpc：0x8000_0010                       | 通过     |

#### `WriteBackUnit`

该模块的作用是选择需要写回的数据传递给寄存器堆，附带寄存器使能信号。

| 测试编号 | 测试内容 | 输入条件                           | 期望结果 | 实际结果 |
| -------- | -------- | ---------------------------------- | -------- | -------- |
| 1        | 选择器   | 三个输入分别是1，2，3，选择信号为0 | 1        | 通过     |
| 2        | 选择器   | 三个输入分别是1，2，3，选择信号为1 | 2        | 通过     |
| 3        | 选择器   | 三个输入分别是1，2，3，选择信号为2 | 3        | 通过     |
| 4        | 选择器   | 三个输入分别是1，2，3，选择信号为3 | 0        | 通过     |

